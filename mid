"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     TEMPLATE EXAMEN DATA SCIENCE                             â•‘
â•‘                     Toate funcÈ›iile de care ai nevoie!                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INSTRUCÈšIUNI:
1. CopiazÄƒ acest template pentru fiecare examen
2. ÃnlocuieÈ™te "TODO" cu datele tale
3. ApeleazÄƒ funcÈ›iile pregÄƒtite
4. SalveazÄƒ des!

Autor: Alexandra
Data: 2025-11-16
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from typing import Union, List, Tuple

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                          0. CONFIGURARE INIÈšIALÄ‚
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pd.set_option('display.max_columns', None)
pd.set_option('display.width', None)
pd.set_option('display.max_rows', 100)
pd.set_option('display.float_format', '{:.2f}'.format)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                          1. FUNCÈšII DE DEBUGGING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def debug_df(df: pd.DataFrame, name: str = "DataFrame") -> None:
    """
    ğŸ” FUNCÈšIE DE DEBUG - Vezi tot despre un DataFrame
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul de analizat
        - name: Nume descriptiv pentru afiÈ™are
    
    ğŸ“¤ OUTPUT:
        - PrinteazÄƒ informaÈ›ii complete (nu returneazÄƒ nimic)
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - CÃ¢nd ai primit un DataFrame È™i vrei sÄƒ vezi ce conÈ›ine
        - DupÄƒ fiecare operaÈ›ie importantÄƒ (merge, groupby, etc.)
        - CÃ¢nd nu Ã®nÈ›elegi de ce nu merge ceva
    
    ğŸ“Š VIZUAL:
        DataFrame "Date Industrie" (150 rows x 8 cols)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Index   â”‚  Carne  â”‚ Peste  â”‚  ...  â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  12345   â”‚   100   â”‚   50   â”‚  ...  â”‚
        â”‚  12346   â”‚   200   â”‚   30   â”‚  ...  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
        
    ğŸ’¡ EXEMPLU:
        debug_df(industria_alimentara, "Date Industrie")
    """
    print(f"\n{'='*80}")
    print(f"ğŸ” {name.upper()}")
    print(f"{'='*80}")
    print(f"ğŸ“Š Shape (rÃ¢nduri Ã— coloane): {df.shape}")
    print(f"ğŸ“‹ Columns: {list(df.columns)}")
    print(f"ğŸ”‘ Index name: {df.index.name}")
    print(f"ğŸ’¾ Memory usage: {df.memory_usage(deep=True).sum() / 1024:.2f} KB")
    
    print(f"\nğŸ“ PRIMELE 3 RÃ‚NDURI:")
    print(df.head(3))
    
    print(f"\nğŸ“Š TIPURI DE DATE:")
    print(df.dtypes)
    
    print(f"\nâš ï¸  VALORI NULL:")
    null_counts = df.isnull().sum()
    if null_counts.sum() > 0:
        print(null_counts[null_counts > 0])
    else:
        print("âœ… Nu existÄƒ valori NULL")
    
    print(f"\nğŸ“ˆ STATISTICI NUMERICE:")
    print(df.describe())
    
    print(f"{'='*80}\n")


def compara_before_after(df_before: pd.DataFrame, df_after: pd.DataFrame, 
                         operation: str = "OperaÈ›ie") -> None:
    """
    ğŸ”„ COMPARÄ‚ ÃNAINTE È˜I DUPÄ‚ O OPERAÈšIE
    
    ğŸ“¥ INPUT:
        - df_before: DataFrame Ã®nainte de operaÈ›ie
        - df_after: DataFrame dupÄƒ operaÈ›ie
        - operation: Numele operaÈ›iei
    
    ğŸ“¤ OUTPUT:
        - PrinteazÄƒ comparaÈ›ie (nu returneazÄƒ nimic)
    
    ğŸ“Š VIZUAL:
        ÃNAINTE: 200 rows Ã— 8 cols    â†’    DUPÄ‚: 150 rows Ã— 8 cols
        DiferenÈ›Äƒ: -50 rows (-25%)
    
    ğŸ’¡ EXEMPLU:
        df_filtrat = filtrare_angajati_pozitivi(df)
        compara_before_after(df, df_filtrat, "Filtrare angajaÈ›i > 0")
    """
    print(f"\n{'â”€'*80}")
    print(f"ğŸ”„ COMPARAÈšIE: {operation}")
    print(f"{'â”€'*80}")
    print(f"ğŸ“Š ÃNAINTE: {df_before.shape[0]:,} rÃ¢nduri Ã— {df_before.shape[1]} coloane")
    print(f"ğŸ“Š DUPÄ‚:    {df_after.shape[0]:,} rÃ¢nduri Ã— {df_after.shape[1]} coloane")
    
    diff_rows = df_after.shape[0] - df_before.shape[0]
    diff_cols = df_after.shape[1] - df_before.shape[1]
    
    if diff_rows != 0:
        pct_rows = (diff_rows / df_before.shape[0]) * 100
        print(f"ğŸ“‰ DiferenÈ›Äƒ rÃ¢nduri: {diff_rows:+,} ({pct_rows:+.1f}%)")
    
    if diff_cols != 0:
        print(f"ğŸ“‰ DiferenÈ›Äƒ coloane: {diff_cols:+,}")
    
    print(f"{'â”€'*80}\n")


def verifica_rezultat(df: Union[pd.DataFrame, pd.Series], 
                      tip_asteptat: str = "DataFrame",
                      trebuie_sa_aiba_date: bool = True) -> bool:
    """
    âœ… VERIFICÄ‚ DACÄ‚ REZULTATUL E VALID
    
    ğŸ“¥ INPUT:
        - df: Rezultatul de verificat
        - tip_asteptat: "DataFrame" sau "Series"
        - trebuie_sa_aiba_date: True dacÄƒ nu trebuie sÄƒ fie gol
    
    ğŸ“¤ OUTPUT:
        - True dacÄƒ e valid, False altfel
    
    ğŸ’¡ EXEMPLU:
        result = calculeaza_ceva(df)
        if verifica_rezultat(result, "Series", True):
            result.to_csv("output.csv")
    """
    valid = True
    
    # VerificÄƒ tipul
    if tip_asteptat == "DataFrame" and not isinstance(df, pd.DataFrame):
        print(f"âŒ EROARE: AÈ™teptat DataFrame, primit {type(df).__name__}")
        valid = False
    elif tip_asteptat == "Series" and not isinstance(df, pd.Series):
        print(f"âŒ EROARE: AÈ™teptat Series, primit {type(df).__name__}")
        valid = False
    
    # VerificÄƒ dacÄƒ are date
    if trebuie_sa_aiba_date and len(df) == 0:
        print(f"âŒ EROARE: Rezultatul este gol!")
        valid = False
    
    # VerificÄƒ NaN
    if isinstance(df, pd.DataFrame):
        nan_count = df.isnull().sum().sum()
    else:
        nan_count = df.isnull().sum()
    
    if nan_count > 0:
        print(f"âš ï¸  WARNING: {nan_count} valori NaN Ã®n rezultat")
    
    if valid:
        print(f"âœ… Rezultat valid: {type(df).__name__} cu {len(df)} elemente")
    
    return valid


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    2. FUNCÈšII DE ÃNCÄ‚RCARE DATE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def incarca_csv_safe(filepath: str, index_col: int = 0, 
                     encoding: str = 'utf-8') -> pd.DataFrame:
    """
    ğŸ“‚ ÃNCARCÄ‚ CSV CU GESTIONARE ERORI
    
    ğŸ“¥ INPUT:
        - filepath: Calea cÄƒtre fiÈ™ier (ex: "data_in/fisier.csv")
        - index_col: Care coloanÄƒ devine index (0 = prima, None = niciuna)
        - encoding: Encodingul fiÈ™ierului (utf-8, latin1, cp1252)
    
    ğŸ“¤ OUTPUT:
        - DataFrame Ã®ncÄƒrcat SAU None dacÄƒ a eÈ™uat
    
    ğŸ“Š VIZUAL:
        CSV File                    DataFrame
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
        â”‚ ID,Nume    â”‚             â”‚  Index   â”‚Nume â”‚
        â”‚ 1,Ana      â”‚    â†’        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
        â”‚ 2,Ion      â”‚             â”‚    1     â”‚ Ana â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚    2     â”‚ Ion â”‚
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
    
    ğŸ’¡ EXEMPLU:
        df = incarca_csv_safe("data_in/IndustriaAlimentara.csv", index_col=0)
        if df is not None:
            print("âœ… Date Ã®ncÄƒrcate!")
    """
    try:
        df = pd.read_csv(filepath, index_col=index_col, encoding=encoding)
        print(f"âœ… FiÈ™ier Ã®ncÄƒrcat: {filepath}")
        print(f"   Shape: {df.shape}")
        return df
    except FileNotFoundError:
        print(f"âŒ EROARE: FiÈ™ierul nu existÄƒ: {filepath}")
        return None
    except Exception as e:
        print(f"âŒ EROARE la Ã®ncÄƒrcare: {e}")
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    3. FUNCÈšII DE FILTRARE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def filtrare_suma_coloane_pozitiva(df: pd.DataFrame, 
                                    coloane: List[str]) -> pd.DataFrame:
    """
    ğŸ” FILTREAZÄ‚ RÃ‚NDURI CU SUMA POZITIVÄ‚
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul de filtrat
        - coloane: Lista cu numele coloanelor de sumat
    
    ğŸ“¤ OUTPUT:
        - DataFrame filtrat (doar rÃ¢nduri cu sumÄƒ > 0)
    
    ğŸ“Š VIZUAL:
        ÃNAINTE:                          DUPÄ‚:
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚Carne â”‚Peste â”‚          â”‚ OraÈ™ â”‚Carne â”‚Peste â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚ 100  â”‚  50  â”‚ â†’ 150   â”‚  A   â”‚ 100  â”‚  50  â”‚ âœ…
        â”‚  B   â”‚  0   â”‚  0   â”‚ â†’   0   â”‚  C   â”‚  0   â”‚  30  â”‚ âœ…
        â”‚  C   â”‚  0   â”‚  30  â”‚ â†’  30   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜          (OraÈ™ul B eliminat)
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - Eliminare localitÄƒÈ›i fÄƒrÄƒ angajaÈ›i
        - Eliminare date incomplete/invalide
    
    ğŸ’¡ EXEMPLU:
        industrii = ['Carne', 'Peste', 'Lactate', 'Panificatie']
        df_valid = filtrare_suma_coloane_pozitiva(df, industrii)
    """
    # CalculÄƒm suma pe coloanele specificate
    suma = df[coloane].sum(axis=1)
    
    # FiltrÄƒm
    df_filtrat = df[suma > 0].copy()
    
    print(f"ğŸ” Filtrare: {len(df)} â†’ {len(df_filtrat)} rÃ¢nduri "
          f"(eliminate: {len(df) - len(df_filtrat)})")
    
    return df_filtrat


def filtrare_multipla_conditii(df: pd.DataFrame, 
                               conditii: List[Tuple[str, str, any]]) -> pd.DataFrame:
    """
    ğŸ¯ FILTRARE CU MULTIPLE CONDIÈšII
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul de filtrat
        - conditii: Lista de tuple (coloana, operator, valoare)
                   Operatori: '>', '<', '>=', '<=', '==', '!='
    
    ğŸ“¤ OUTPUT:
        - DataFrame filtrat
    
    ğŸ“Š VIZUAL:
        CONDIÈšII: Populatie > 10000 AND Carne > 50
        
        ÃNAINTE (100 rÃ¢nduri)  â†’  DUPÄ‚ (25 rÃ¢nduri)
        PÄƒstreazÄƒ doar rÃ¢ndurile care Ã®ndeplinesc TOATE condiÈ›iile
    
    ğŸ’¡ EXEMPLU:
        conditii = [
            ('Populatie', '>', 10000),
            ('Carne', '>=', 50),
            ('Judet', '==', 'BUC')
        ]
        df_filtrat = filtrare_multipla_conditii(df, conditii)
    """
    mask = pd.Series([True] * len(df), index=df.index)
    
    for col, op, val in conditii:
        if op == '>':
            mask &= (df[col] > val)
        elif op == '<':
            mask &= (df[col] < val)
        elif op == '>=':
            mask &= (df[col] >= val)
        elif op == '<=':
            mask &= (df[col] <= val)
        elif op == '==':
            mask &= (df[col] == val)
        elif op == '!=':
            mask &= (df[col] != val)
    
    df_filtrat = df[mask].copy()
    
    print(f"ğŸ¯ Filtrare cu {len(conditii)} condiÈ›ii: "
          f"{len(df)} â†’ {len(df_filtrat)} rÃ¢nduri")
    
    return df_filtrat


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    4. FUNCÈšII DE TRANSFORMARE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def normalizare_pe_rand(df: pd.DataFrame, coloane: List[str], 
                        inlocuire_nan: float = 0) -> pd.DataFrame:
    """
    ğŸ“Š NORMALIZARE: TransformÄƒ valori absolute â†’ procente
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul
        - coloane: Coloanele de normalizat
        - inlocuire_nan: Cu ce Ã®nlocuim NaN (apare cÃ¢nd suma = 0)
    
    ğŸ“¤ OUTPUT:
        - DataFrame cu coloanele normalizate (valori Ã®ntre 0 È™i 1)
    
    ğŸ“Š VIZUAL:
        ÃNAINTE (Valori absolute):        DUPÄ‚ (ProporÈ›ii):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚Carne â”‚Peste â”‚           â”‚ OraÈ™ â”‚Carne â”‚Peste â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚ 60   â”‚ 40   â”‚ (Î£=100)  â”‚  A   â”‚ 0.6  â”‚ 0.4  â”‚
        â”‚  B   â”‚ 200  â”‚ 100  â”‚ (Î£=300)  â”‚  B   â”‚ 0.67 â”‚ 0.33 â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
        
        Formula: valoare_nouÄƒ = valoare_veche / suma_rÃ¢ndului
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - Calculare procente
        - Comparare proporÈ›ii Ã®ntre entitÄƒÈ›i de dimensiuni diferite
        - CerinÈ›e de forma "procentul de angajaÈ›i pe fiecare activitate"
    
    ğŸ’¡ EXEMPLU:
        industrii = ['Carne', 'Peste', 'Lactate']
        df_procente = normalizare_pe_rand(df, industrii, inlocuire_nan=0)
    """
    df_norm = df.copy()
    
    # NormalizÄƒm: fiecare valoare / suma rÃ¢ndului
    df_norm[coloane] = df[coloane].apply(
        lambda x: x / x.sum() if x.sum() > 0 else x,
        axis=1
    )
    
    # Ãnlocuim NaN
    df_norm[coloane] = df_norm[coloane].fillna(inlocuire_nan)
    
    print(f"ğŸ“Š Normalizare pe {len(coloane)} coloane")
    print(f"   Range valori: [{df_norm[coloane].min().min():.3f}, "
          f"{df_norm[coloane].max().max():.3f}]")
    
    return df_norm


def calculeaza_pondere(df: pd.DataFrame, 
                      col_numerator: str, 
                      col_denominator: str,
                      nume_noua_coloana: str = "Pondere") -> pd.Series:
    """
    â— CALCULEAZÄ‚ PONDERE (RAPORT ÃNTRE DOUÄ‚ COLOANE)
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul
        - col_numerator: Coloana de la numÄƒrÄƒtor
        - col_denominator: Coloana de la numitor
        - nume_noua_coloana: Numele rezultatului
    
    ğŸ“¤ OUTPUT:
        - Series cu ponderile calculate
    
    ğŸ“Š VIZUAL:
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚ AngajaÈ›i â”‚PopulaÈ›ie â”‚     â”‚ OraÈ™ â”‚ Pondere â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â†’  â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚   1000   â”‚  50000   â”‚     â”‚  A   â”‚  0.02   â”‚ (2%)
        â”‚  B   â”‚   500    â”‚  100000  â”‚     â”‚  B   â”‚  0.005  â”‚ (0.5%)
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Formula: Pondere = AngajaÈ›i / PopulaÈ›ie
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - "Ponderea angajaÈ›ilor Ã®n populaÈ›ie"
        - "Rata de..." / "Procentul de..."
        - Orice raport Ã®ntre douÄƒ mÄƒrimi
    
    ğŸ’¡ EXEMPLU:
        pondere = calculeaza_pondere(df, 'Angajati_Total', 'Populatie', 'Pondere_Angajati')
    """
    # CalculÄƒm ponderea
    pondere = df[col_numerator] / df[col_denominator]
    
    # Ãnlocuim inf È™i nan (apar cÃ¢nd Ã®mpÄƒrÈ›im la 0)
    pondere = pondere.replace([np.inf, -np.inf], 0)
    pondere = pondere.fillna(0)
    
    pondere.name = nume_noua_coloana
    
    print(f"â— Pondere calculatÄƒ: {col_numerator} / {col_denominator}")
    print(f"   Range: [{pondere.min():.4f}, {pondere.max():.4f}]")
    print(f"   Medie: {pondere.mean():.4f}")
    
    return pondere


def medie_ponderata(t: pd.DataFrame) -> pd.Series:
    """
    âš–ï¸ MEDIE PONDERATÄ‚ (ultima coloanÄƒ = ponderi)
    
    ğŸ“¥ INPUT:
        - t: DataFrame cu:
            * Coloanele 0 pÃ¢nÄƒ la -2: Valorile de mediat
            * Coloana -1 (ultima): Ponderile
    
    ğŸ“¤ OUTPUT:
        - Series cu mediile ponderate pentru fiecare coloanÄƒ
    
    ğŸ“Š VIZUAL:
        INPUT DataFrame:
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚Carne â”‚Peste â”‚PopulaÈ›ieâ”‚ â† Ponderi
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚  10  â”‚  5   â”‚  1000    â”‚
        â”‚  B   â”‚  50  â”‚  30  â”‚  10000   â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        OUTPUT Series:
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚Carne â”‚ (10Ã—1000 + 50Ã—10000) / (1000+10000) = 48.2 â”‚
        â”‚Peste â”‚ (5Ã—1000 + 30Ã—10000) / (1000+10000) = 29.1  â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        Formula: media = Î£(valoare_i Ã— pondere_i) / Î£(pondere_i)
        
        âš ï¸ DIFERENÈšA vs MEDIE SIMPLÄ‚:
        Medie simplÄƒ Carne: (10+50)/2 = 30 âŒ
        Medie ponderatÄƒ Carne: 48.2 âœ… (oraÈ™ul B conteazÄƒ mai mult!)
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - "Media ponderatÄƒ folosind populaÈ›ia ca pondere"
        - CÃ¢nd vrei medie dar entitÄƒÈ›ile mari conteazÄƒ mai mult
        - Agregare la nivel superior pÄƒstrÃ¢nd importanÈ›a relativÄƒ
    
    ğŸ’¡ EXEMPLU:
        # GrupÄƒm pe regiuni È™i calculÄƒm medie ponderatÄƒ
        medii = df.groupby('Regiune').apply(medie_ponderata, include_groups=False)
    """
    x = t.values  # Convertim Ã®n NumPy array pentru vitezÄƒ
    
    # np.average: calculeazÄƒ media ponderatÄƒ
    m = np.average(
        x[:, :-1],      # Toate coloanele MINUS ultima (valorile)
        axis=0,          # Media pe coloane (â†“ vertical)
        weights=x[:, -1] # Ultima coloanÄƒ (ponderile)
    )
    
    return pd.Series(m, t.columns[:-1])


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    5. FUNCÈšII DE COMBINARE (MERGE/JOIN)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def merge_safe(df1: pd.DataFrame, df2: pd.DataFrame,
               left_on: str = None, right_on: str = None,
               left_index: bool = False, right_index: bool = False,
               how: str = 'inner',
               suffixes: Tuple[str, str] = ('_left', '_right')) -> pd.DataFrame:
    """
    ğŸ”— MERGE (JOIN) SIGUR CU VERIFICÄ‚RI
    
    ğŸ“¥ INPUT:
        - df1, df2: DataFrame-urile de combinat
        - left_on: Coloana din df1 pentru join (SAU None dacÄƒ folosim index)
        - right_on: Coloana din df2 pentru join (SAU None dacÄƒ folosim index)
        - left_index: True dacÄƒ joinÄƒm pe index-ul df1
        - right_index: True dacÄƒ joinÄƒm pe index-ul df2
        - how: Tipul de join:
            * 'inner' - doar ce matches Ã®n ambele (implicit)
            * 'left' - toate din df1, completeazÄƒ cu NaN
            * 'right' - toate din df2, completeazÄƒ cu NaN
            * 'outer' - toate din ambele
        - suffixes: Sufixe pentru coloane duplicate
    
    ğŸ“¤ OUTPUT:
        - DataFrame combinat
    
    ğŸ“Š VIZUAL:
        
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘  TIPURI DE JOIN (how parameter)                           â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        TABEL 1 (Industrie):      TABEL 2 (PopulaÈ›ie):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚AngajaÈ›i â”‚        â”‚ OraÈ™ â”‚PopulaÈ›ieâ”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚  100    â”‚        â”‚  A   â”‚  5000    â”‚
        â”‚  B   â”‚  200    â”‚        â”‚  C   â”‚  8000    â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        INNER JOIN (how='inner'):     LEFT JOIN (how='left'):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚AngajaÈ›i â”‚PopulaÈ›ieâ”‚ â”‚ OraÈ™ â”‚AngajaÈ›i â”‚PopulaÈ›ieâ”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚  100    â”‚  5000    â”‚ â”‚  A   â”‚  100    â”‚  5000    â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  B   â”‚  200    â”‚  NaN     â”‚
        (Doar A - comun ambelor)       â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       (Toate din stÃ¢nga)
        
        OUTER JOIN (how='outer'):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚AngajaÈ›i â”‚PopulaÈ›ieâ”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚  100    â”‚  5000    â”‚
        â”‚  B   â”‚  200    â”‚  NaN     â”‚
        â”‚  C   â”‚  NaN    â”‚  8000    â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        (Toate din ambele)
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - Combinare date din surse diferite
        - ÃmbogÄƒÈ›ire date (ex: adaug populaÈ›ie la industrie)
        - Asociere coduri (ex: judeÈ› â†’ regiune)
    
    ğŸ’¡ EXEMPLE:
        # Join pe index (coduri SIRUTA)
        df_full = merge_safe(industria, populatie, 
                            left_index=True, right_index=True)
        
        # Join pe coloanÄƒ
        df_full = merge_safe(df1, coduri_judete,
                            left_on='Judet', right_index=True,
                            how='left')
    """
    print(f"ğŸ”— Merge: {len(df1)} rows Ã— {len(df2)} rows")
    
    # ExecutÄƒm merge
    df_merged = df1.merge(
        df2,
        left_on=left_on,
        right_on=right_on,
        left_index=left_index,
        right_index=right_index,
        how=how,
        suffixes=suffixes
    )
    
    print(f"   Rezultat: {len(df_merged)} rows Ã— {df_merged.shape[1]} cols")
    
    # VerificÄƒri
    if how == 'inner' and len(df_merged) < min(len(df1), len(df2)):
        print(f"   âš ï¸  WARNING: Pierdere date ({min(len(df1), len(df2)) - len(df_merged)} rÃ¢nduri)")
    
    nan_cols = df_merged.columns[df_merged.isnull().any()].tolist()
    if nan_cols:
        print(f"   âš ï¸  Coloane cu NaN dupÄƒ merge: {nan_cols}")
    
    return df_merged


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    6. FUNCÈšII DE AGREGARE (GROUPBY)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def agreg are_simpla(df: pd.DataFrame, 
                    col_grupare: str,
                    coloane_agregate: List[str],
                    functie: str = 'sum') -> pd.DataFrame:
    """
    ğŸ“Š AGREGARE SIMPLÄ‚ LA NIVEL SUPERIOR
    
    ğŸ“¥ INPUT:
        - df: DataFrame-ul
        - col_grupare: Coloana dupÄƒ care grupÄƒm (ex: 'Judet', 'Regiune')
        - coloane_agregate: Coloanele de agregat
        - functie: FuncÈ›ia de agregare:
            * 'sum' - sumÄƒ
            * 'mean' - medie
            * 'count' - numÄƒr
            * 'min' / 'max' - min/max
    
    ğŸ“¤ OUTPUT:
        - DataFrame agregat la nivel superior
    
    ğŸ“Š VIZUAL:
        ÃNAINTE (Nivel localitÄƒÈ›i):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
        â”‚ OraÈ™ â”‚JudeÈ› â”‚Carne â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
        â”‚  A   â”‚ BUC  â”‚ 100  â”‚
        â”‚  B   â”‚ BUC  â”‚ 200  â”‚  } BUC: 100+200 = 300
        â”‚  C   â”‚ CJ   â”‚ 150  â”‚  } CJ: 150
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
               â†“ groupby('Judet').sum()
        
        DUPÄ‚ (Nivel judeÈ›e):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
        â”‚JudeÈ› â”‚Carne â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
        â”‚ BUC  â”‚ 300  â”‚
        â”‚ CJ   â”‚ 150  â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - "La nivel de judeÈ›" â†’ grupÄƒm localitÄƒÈ›ile
        - "La nivel de regiune" â†’ grupÄƒm judeÈ›ele
        - "Total per categorie"
    
    ğŸ’¡ EXEMPLU:
        # AgregÄƒm localitÄƒÈ›i â†’ judeÈ›e
        df_judete = agregare_simpla(df, 'Judet', 
                                    ['Carne', 'Peste', 'Populatie'], 
                                    'sum')
    """
    func_dict = {
        'sum': 'sum',
        'mean': 'mean',
        'count': 'count',
        'min': 'min',
        'max': 'max'
    }
    
    if functie not in func_dict:
        print(f"âŒ FuncÈ›ie invalidÄƒ: {functie}. Folosesc 'sum'")
        functie = 'sum'
    
    # SelectÄƒm coloanele È™i grupÄƒm
    df_agregat = df[coloane_agregate + [col_grupare]].groupby(
        by=col_grupare
    ).agg(func_dict[functie])
    
    print(f"ğŸ“Š Agregare {functie.upper()}: {len(df)} â†’ {len(df_agregat)} "
          f"grupe dupÄƒ '{col_grupare}'")
    
    return df_agregat


def gaseste_dominant_pe_grup(df: pd.DataFrame,
                            col_grupare: str,
                            coloane_competitie: List[str]) -> pd.Series:
    """
    ğŸ† GÄ‚SEÈ˜TE CATEGORIA DOMINANTÄ‚ PENTRU FIECARE GRUP
    
    ğŸ“¥ INPUT:
        - df: DataFrame agregat (deja la nivel superior!)
        - col_grupare: Coloana de grupare
        - coloane_competitie: Coloanele Ã®ntre care cÄƒutÄƒm maximul
    
    ğŸ“¤ OUTPUT:
        - Series cu numele coloanei dominante pentru fiecare grup
    
    ğŸ“Š VIZUAL:
        INPUT (DataFrame agregat la nivel judeÈ›e):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚JudeÈ› â”‚Carne â”‚Peste â”‚ Panificatie â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ BUC  â”‚ 500  â”‚ 300  â”‚    800      â”‚ â†’ MAX: Panificatie
        â”‚ CJ   â”‚ 600  â”‚ 200  â”‚    400      â”‚ â†’ MAX: Carne
        â”‚ TM   â”‚ 300  â”‚ 450  â”‚    200      â”‚ â†’ MAX: Peste
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â†“
        OUTPUT (Series):
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚JudeÈ› â”‚ Activitate  â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ BUC  â”‚Panificatie  â”‚
        â”‚ CJ   â”‚ Carne       â”‚
        â”‚ TM   â”‚ Peste       â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - "Activitatea cu cei mai mulÈ›i angajaÈ›i la nivel de judeÈ›"
        - "Industria dominantÄƒ per regiune"
        - Orice "care dintre X are valoarea maximÄƒ?"
    
    ğŸ’¡ EXEMPLU:
        # 1. AgregÄƒm la nivel judeÈ›
        df_judet = agregare_simpla(df, 'Judet', industrii, 'sum')
        
        # 2. GÄƒsim activitatea dominantÄƒ
        dominant = gaseste_dominant_pe_grup(df_judet, 'Judet', industrii)
    """
    # AgregÄƒm dacÄƒ nu e deja agregat
    if col_grupare in df.columns:
        df_agregat = df.groupby(col_grupare)[coloane_competitie].sum()
    else:
        df_agregat = df[coloane_competitie]
    
    # GÄƒsim coloana cu valoarea maximÄƒ pentru fiecare rÃ¢nd
    dominant = df_agregat.apply(
        lambda x: x.index[x.argmax()],  # x.argmax() = poziÈ›ia max
        axis=1                           # x.index[...] = numele coloanei
    )
    
    dominant.name = "Activitate_Dominanta"
    
    print(f"ğŸ† ActivitÄƒÈ›i dominante gÄƒsite pentru {len(dominant)} grupe")
    print(f"   DistribuÈ›ie: \n{dominant.value_counts()}")
    
    return dominant


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    7. FUNCÈšII DE CALCUL INDICI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def calculeaza_indice_localizare(df_judet: pd.DataFrame,
                                 coloane_activitati: List[str],
                                 col_populatie: str = 'Populatie') -> pd.DataFrame:
    """
    ğŸ“ INDICE DE LOCALIZARE (Location Quotient)
    
    ğŸ“¥ INPUT:
        - df_judet: DataFrame agregat la nivel judeÈ› cu:
            * Coloane pentru fiecare activitate (angajaÈ›i)
            * ColoanÄƒ cu populaÈ›ia
        - coloane_activitati: Lista cu coloanele de activitÄƒÈ›i
        - col_populatie: Numele coloanei cu populaÈ›ia
    
    ğŸ“¤ OUTPUT:
        - DataFrame cu indicii de localizare pentru fiecare judeÈ›Ã—activitate
    
    ğŸ“Š VIZUAL & EXPLICAÈšIE:
        
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘  CE MÄ‚SOARÄ‚?                                              â•‘
        â•‘  DacÄƒ un judeÈ› e SPECIALIZAT Ã®ntr-o anumitÄƒ industrie    â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        Formula:
        IL = (AngajaÈ›i_JudeÈ›_X_Industria_Y / Total_AngajaÈ›i_JudeÈ›_X) 
             Ã·
             (AngajaÈ›i_NaÈ›ional_Industria_Y / Total_AngajaÈ›i_NaÈ›ional)
        
        SAU mai simplu:
        IL = (Pondere_JudeÈ›_Ã®n_Industrie) / (Pondere_JudeÈ›_Ã®n_PopulaÈ›ie)
        
        INTERPRETARE:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ IL > 1       â”‚ JudeÈ› SPECIALIZAT (peste medie)    â”‚
        â”‚ IL = 1       â”‚ La nivelul mediei naÈ›ionale         â”‚
        â”‚ IL < 1       â”‚ Sub medie naÈ›ionalÄƒ                 â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        
        EXEMPLU CONCRET:
        JudeÈ› X: 3000 angajaÈ›i carne din 100000 total angajaÈ›i (3%)
        NaÈ›ional: 20000 angajaÈ›i carne din 500000 total angajaÈ›i (4%)
        IL = 3% / 4% = 0.75 < 1 â†’ SUB MEDIE (nu e specializat)
        
        JudeÈ› Y: 8000 angajaÈ›i carne din 100000 total angajaÈ›i (8%)
        NaÈ›ional: 20000 angajaÈ›i carne din 500000 total angajaÈ›i (4%)
        IL = 8% / 4% = 2 > 1 â†’ SPECIALIZAT (de 2Ã— peste medie!)
    
    ğŸ¯ CÃ‚ND O FOLOSEÈ˜TI:
        - "CalculaÈ›i indicii de localizare la nivel de judeÈ›"
        - "Care judeÈ›e sunt specializate Ã®n care industrii?"
        - AnalizÄƒ de specializare regionalÄƒ
    
    ğŸ’¡ EXEMPLU:
        indici = calculeaza_indice_localizare(
            df_judet, 
            ['Carne', 'Peste', 'Lactate'], 
            'Populatie'
        )
    """
    # 1. CalculÄƒm totalurile naÈ›ionale
    total_national = df_judet.sum(axis=0)
    
    print(f"ğŸ“ Calcul indici localizare...")
    print(f"   Total naÈ›ional angajaÈ›i: {total_national[coloane_activitati].sum():,.0f}")
    print(f"   Total naÈ›ional populaÈ›ie: {total_national[col_populatie]:,.0f}")
    
    # 2. CalculÄƒm indicele pentru fiecare judeÈ› È™i activitate
    indici = df_judet[coloane_activitati].apply(
        lambda x: (
            (x / total_national[coloane_activitati]) /  # Pondere Ã®n activitate
            (df_judet.loc[x.name, col_populatie] / total_national[col_populatie])  # Pondere populaÈ›ie
        ),
        axis=1
    )
    
    # 3. GestionÄƒm diviziuni la 0
    indici = indici.replace([np.inf, -np.inf], 0)
    indici = indici.fillna(0)
    
    # 4. Statistici
    print(f"   Range indici: [{indici.min().min():.2f}, {indici.max().max():.2f}]")
    print(f"   JudeÈ›e specializate (IL>1): {(indici > 1).sum().sum()} cazuri")
    
    return indici


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    8. FUNCÈšII DE SORTARE È˜I EXPORT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def sorteaza_si_salveaza(date: Union[pd.DataFrame, pd.Series],
                        filepath: str,
                        ascending: bool = False,
                        col_sortare: str = None) -> None:
    """
    ğŸ’¾ SORTEAZÄ‚ È˜I SALVEAZÄ‚ REZULTATUL
    
    ğŸ“¥ INPUT:
        - date: DataFrame sau Series de salvat
        - filepath: Calea fiÈ™ierului output (ex: "data_out/Cerinta1.csv")
        - ascending: True = crescÄƒtor, False = descrescÄƒtor
        - col_sortare: Coloana de sortare (doar pentru DataFrame)
    
    ğŸ“¤ OUTPUT:
        - FiÈ™ier CSV salvat (nu returneazÄƒ nimic)
    
    ğŸ“Š VIZUAL:
        Date nesortate  â†’  Sortare  â†’  Export CSV
        â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
        â”‚JudeÈ› â”‚Valoareâ”‚   â”‚JudeÈ› â”‚Valoareâ”‚
        â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
        â”‚ CJ   â”‚ 0.15 â”‚   â”‚ BUC  â”‚ 0.30 â”‚ â†“ DescrescÄƒtor
        â”‚ BUC  â”‚ 0.30 â”‚   â”‚ TM   â”‚ 0.20 â”‚
        â”‚ TM   â”‚ 0.20 â”‚   â”‚ CJ   â”‚ 0.15 â”‚
        â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
    
    ğŸ’¡ EXEMPLU:
        # Pentru Series
        sorteaza_si_salveaza(pondere_judete, "data_out/Cerinta3.csv", 
                            ascending=False)
        
        # Pentru DataFrame
        sorteaza_si_salveaza(df_rezultat, "data_out/Cerinta1.csv",
                            ascending=False, col_sortare='Populatie')
    """
    date_sortate = date.copy()
    
    # SortÄƒm
    if isinstance(date, pd.Series):
        date_sortate = date_sortate.sort_values(ascending=ascending)
    else:
        if col_sortare:
            date_sortate = date_sortate.sort_values(by=col_sortare, ascending=ascending)
        else:
            print("âš ï¸  DataFrame fÄƒrÄƒ coloanÄƒ de sortare specificatÄƒ - nu sortez")
    
    # SalvÄƒm
    date_sortate.to_csv(filepath)
    
    directie = "crescÄƒtor" if ascending else "descrescÄƒtor"
    print(f"ğŸ’¾ Salvat: {filepath}")
    print(f"   {len(date_sortate)} rÃ¢nduri, sortat {directie}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    9. WORKFLOW COMPLET - TEMPLATE REZOLVARE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def template_cerinta_standard(
    df_principal: pd.DataFrame,
    df_secundar: pd.DataFrame = None,
    coloane_lucru: List[str] = None,
    tip_operatie: str = 'filtrare',
    parametri: dict = None,
    output_file: str = None
) -> Union[pd.DataFrame, pd.Series]:
    """
    ğŸ¯ TEMPLATE GENERIC PENTRU CERINÈšE
    
    Acest template acoperÄƒ majoritatea pattern-urilor de cerinÈ›e.
    AdapteazÄƒ parametrii Ã®n funcÈ›ie de cerinÈ›Äƒ.
    
    ğŸ“¥ INPUT:
        - df_principal: DataFrame-ul principal
        - df_secundar: DataFrame secundar pentru merge (optional)
        - coloane_lucru: Coloanele pe care lucrÄƒm
        - tip_operatie: Tipul operaÈ›iei:
            * 'filtrare' - eliminÄƒ rÃ¢nduri
            * 'normalizare' - transformÄƒ Ã®n procente
            * 'pondere' - calculeazÄƒ raport
            * 'agregare' - groupby + sum/mean
            * 'dominant' - gÄƒseÈ™te max per grup
            * 'indice' - calcul indici localizare
        - parametri: DicÈ›ionar cu parametri specifici
        - output_file: FiÈ™ier de output (optional)
    
    ğŸ“¤ OUTPUT:
        - DataFrame sau Series cu rezultatul
    
    ğŸ’¡ VEZI SECÈšIUNEA 10 PENTRU EXEMPLE COMPLETE
    """
    rezultat = None
    
    if tip_operatie == 'filtrare':
        rezultat = filtrare_suma_coloane_pozitiva(df_principal, coloane_lucru)
    
    elif tip_operatie == 'normalizare':
        rezultat = normalizare_pe_rand(df_principal, coloane_lucru)
    
    elif tip_operatie == 'pondere':
        if df_secundar is not None:
            df_merge = merge_safe(df_principal, df_secundar, **parametri.get('merge', {}))
            rezultat = calculeaza_pondere(
                df_merge,
                parametri['col_numerator'],
                parametri['col_denominator']
            )
        else:
            rezultat = calculeaza_pondere(
                df_principal,
                parametri['col_numerator'],
                parametri['col_denominator']
            )
    
    elif tip_operatie == 'agregare':
        rezultat = agregare_simpla(
            df_principal,
            parametri['col_grupare'],
            coloane_lucru,
            parametri.get('functie', 'sum')
        )
    
    elif tip_operatie == 'dominant':
        rezultat = gaseste_dominant_pe_grup(
            df_principal,
            parametri['col_grupare'],
            coloane_lucru
        )
    
    elif tip_operatie == 'indice':
        rezultat = calculeaza_indice_localizare(
            df_principal,
            coloane_lucru,
            parametri.get('col_populatie', 'Populatie')
        )
    
    # SalvÄƒm dacÄƒ e specificat
    if output_file and rezultat is not None:
        if parametri and parametri.get('sorteaza', False):
            sorteaza_si_salveaza(
                rezultat,
                output_file,
                parametri.get('ascending', False)
            )
        else:
            rezultat.to_csv(output_file)
            print(f"ğŸ’¾ Salvat: {output_file}")
    
    return rezultat


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                10. REZOLVÄ‚RI COMPLETE - COPY-PASTE READY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def rezolva_toate_cerintele():
    """
    ğŸ¯ REZOLVARE COMPLETÄ‚ - ADAPTEAZÄ‚ PENTRU EXAMENUL TÄ‚U
    
    Aici ai toate cele 6 cerinÈ›e rezolvate PAS CU PAS.
    CopiazÄƒ È™i adapteazÄƒ la datele tale!
    """
    
    print("="*80)
    print("ğŸš€ START REZOLVARE EXAMEN")
    print("="*80)
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # ÃNCÄ‚RCARE DATE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸ“‚ ÃNCÄ‚RCARE DATE...")
    
    industria_alimentara = incarca_csv_safe("data_in/IndustriaAlimentara.csv", index_col=0)
    populatia = incarca_csv_safe("data_in/PopulatieLocalitati.csv", index_col=0)
    coduri_judete = incarca_csv_safe("data_in/Coduri_judete.csv", index_col=0)
    
    if any(df is None for df in [industria_alimentara, populatia, coduri_judete]):
        print("âŒ EROARE: Nu s-au putut Ã®ncÄƒrca toate fiÈ™ierele!")
        return
    
    # IdentificÄƒm coloanele cu industrii
    industrii = list(industria_alimentara.columns)[1:]  # Skip 'Localitate'
    print(f"âœ… Industrii identificate: {industrii}")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 1: Filtrare localitÄƒÈ›i cu angajaÈ›i > 0
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 1: Filtrare localitÄƒÈ›i cu angajaÈ›i > 0")
    print("="*80)
    
    cerinta1 = filtrare_suma_coloane_pozitiva(
        industria_alimentara,
        industrii
    )
    sorteaza_si_salveaza(cerinta1, "data_out/Cerinta1.csv")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 2: Procente pe activitÄƒÈ›i
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 2: Calcul procente pe fiecare activitate")
    print("="*80)
    
    cerinta2 = normalizare_pe_rand(
        industria_alimentara,
        industrii,
        inlocuire_nan=0
    )
    # AdÄƒugÄƒm coloana Localitate
    cerinta2.insert(0, "Localitate", industria_alimentara["Localitate"])
    
    cerinta2.to_csv("data_out/Cerinta2.csv")
    print(f"ğŸ’¾ Salvat: data_out/Cerinta2.csv")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 3: Pondere angajaÈ›i Ã®n populaÈ›ie (pe judeÈ›e)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 3: Pondere angajaÈ›i/populaÈ›ie pe judeÈ›e (sortat)")
    print("="*80)
    
    # 1. Merge industrie + populaÈ›ie
    industria_loc = merge_safe(
        industria_alimentara,
        populatia,
        left_index=True,
        right_index=True,
        how='inner'
    )
    
    # 2. Agregare la nivel judeÈ›
    industria_judet = agregare_simpla(
        industria_loc,
        'Judet',
        industrii + ['Populatie'],
        'sum'
    )
    
    # 3. CalculÄƒm ponderea: total_angajaÈ›i / populaÈ›ie
    cerinta3 = industria_judet.apply(
        lambda x: x[industrii].sum() / x['Populatie'],
        axis=1
    )
    cerinta3.name = "Pondere"
    
    # 4. SortÄƒm descrescÄƒtor È™i salvÄƒm
    sorteaza_si_salveaza(cerinta3, "data_out/Cerinta3.csv", ascending=False)
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 4: Activitatea dominantÄƒ pe judeÈ›
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 4: Activitatea cu cei mai mulÈ›i angajaÈ›i pe judeÈ›")
    print("="*80)
    
    cerinta4 = gaseste_dominant_pe_grup(
        industria_judet,
        'Judet',
        industrii
    )
    
    cerinta4.to_csv("data_out/Cerinta4.csv")
    print(f"ğŸ’¾ Salvat: data_out/Cerinta4.csv")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 5: Media ponderatÄƒ pe regiuni
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 5: Media ponderatÄƒ de angajaÈ›i pe regiuni")
    print("="*80)
    
    # 1. Merge cu coduri judeÈ›e (adaugÄƒ regiunea)
    industria_loc_reg = merge_safe(
        industria_loc,
        coduri_judete,
        left_on='Judet',
        right_index=True,
        how='left'
    )
    
    # 2. GroupBy pe regiune È™i aplicÄƒ medie ponderatÄƒ
    cerinta5 = industria_loc_reg[industrii + ['Populatie', 'Regiune']].groupby(
        by='Regiune'
    ).apply(
        medie_ponderata,
        include_groups=False
    )
    
    cerinta5.to_csv("data_out/Cerinta5.csv")
    print(f"ğŸ’¾ Salvat: data_out/Cerinta5.csv")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # CERINÈšA 6: Indici de localizare
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("ğŸ“Œ CERINÈšA 6: Indici de localizare pe judeÈ›e")
    print("="*80)
    
    cerinta6 = calculeaza_indice_localizare(
        industria_judet,
        industrii,
        'Populatie'
    )
    
    cerinta6.to_csv("data_out/Cerinta6.csv")
    print(f"ğŸ’¾ Salvat: data_out/Cerinta6.csv")
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # FINAL
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "="*80)
    print("âœ… TOATE CERINÈšELE REZOLVATE CU SUCCES!")
    print("="*80)
    
    # Verificare finalÄƒ
    import os
    print("\nğŸ“‹ VERIFICARE FIÈ˜IERE GENERATE:")
    for i in range(1, 7):
        filepath = f"data_out/Cerinta{i}.csv"
        if os.path.exists(filepath):
            size = os.path.getsize(filepath)
            df_check = pd.read_csv(filepath)
            print(f"   âœ… Cerinta{i}.csv - {len(df_check)} rÃ¢nduri, {size:,} bytes")
        else:
            print(f"   âŒ Cerinta{i}.csv - LIPSEÈ˜TE!")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                        11. MAIN - PUNCTUL DE INTRARE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    """
    ğŸ¯ MODUL DE UTILIZARE:
    
    1. PENTRU EXAMEN:
       - DecomenteazÄƒ linia de mai jos
       - RuleazÄƒ scriptul: python template_examen.py
       - Toate cerinÈ›ele se rezolvÄƒ automat!
    
    2. PENTRU TESTARE PAS CU PAS:
       - ComenteazÄƒ rezolva_toate_cerintele()
       - ÃncarcÄƒ datele manual
       - ApeleazÄƒ funcÈ›iile individual
    
    3. PENTRU DEBUG:
       - FoloseÈ™te debug_df() dupÄƒ fiecare pas
       - FoloseÈ™te compara_before_after() pentru a vedea modificÄƒrile
    """
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OPÈšIUNEA 1: REZOLVARE AUTOMATÄ‚ (RECOMANDATÄ‚ PENTRU EXAMEN)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    rezolva_toate_cerintele()
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # OPÈšIUNEA 2: PAS CU PAS (PENTRU ÃNVÄ‚ÈšARE/DEBUG)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # # ÃncarcÄƒ date
    # df = incarca_csv_safe("data_in/IndustriaAlimentara.csv", index_col=0)
    # debug_df(df, "Date Industrie")
    # 
    # # Filtrare
    # df_filtrat = filtrare_suma_coloane_pozitiva(df, ['Carne', 'Peste'])
    # compara_before_after(df, df_filtrat, "Filtrare")
    # 
    # # ... etc


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                        12. QUICK REFERENCE CARD
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                      QUICK REFERENCE - COPY-PASTE                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. ÃNCÄ‚RCARE & DEBUG                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ df = incarca_csv_safe("fisier.csv", index_col=0)                       â”‚
â”‚ debug_df(df, "Nume descriptiv")                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. FILTRARE                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ # EliminÄƒ rÃ¢nduri cu sumÄƒ = 0                                          â”‚
â”‚ df_filtrat = filtrare_suma_coloane_pozitiva(df, ['Col1', 'Col2'])     â”‚
â”‚                                                                          â”‚
â”‚ # Multiple condiÈ›ii                                                     â”‚
â”‚ df_filtrat = filtrare_multipla_conditii(df, [                          â”‚
â”‚     ('Populatie', '>', 10000),                                          â”‚
â”‚     ('Judet', '==', 'BUC')                                             â”‚
â”‚ ])                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. NORMALIZARE (PROCENTE)                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ df_procente = normalizare_pe_rand(df, ['Col1', 'Col2'], 0)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. PONDERE (RAPORT)                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ pondere = calculeaza_pondere(df, 'Angajati', 'Populatie', 'Pondere')  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. MERGE (JOIN)                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ # Pe index                                                              â”‚
â”‚ df_merge = merge


Nu, se pare cÄƒ s-a tÄƒiat! ğŸ˜… Hai sÄƒ-È›i dau un rezumat **SUPER COMPACT** cu cele mai importante funcÈ›ii pentru examen:

---

# ğŸ¯ CHEAT SHEET ULTRA-COMPACT - FUNCÈšII ESENÈšIALE

## ğŸ“‹ TOP 10 FUNCÈšII - COPY-PASTE READY

### **1ï¸âƒ£ ÃNCÄ‚RCARE DATE**
```python
df = pd.read_csv("data_in/fisier.csv", index_col=0)
# index_col=0 â†’ prima coloanÄƒ devine index
```

### **2ï¸âƒ£ FILTRARE (eliminÄƒ rÃ¢nduri cu sumÄƒ = 0)**
```python
industrii = ['Carne', 'Peste', 'Lactate']
suma = df[industrii].sum(axis=1)  # axis=1 = pe rÃ¢nduri
df_filtrat = df[suma > 0]
```

### **3ï¸âƒ£ NORMALIZARE (valori â†’ procente)**
```python
df_procente = df[industrii].apply(lambda x: x/x.sum(), axis=1)
df_procente.fillna(0, inplace=True)  # âš ï¸ OBLIGATORIU dupÄƒ Ã®mpÄƒrÈ›ire!
```

### **4ï¸âƒ£ MERGE (combinÄƒ tabele)**
```python
# Pe INDEX (ambele tabele)
df_complet = df1.merge(df2, left_index=True, right_index=True)

# Pe COLOANÄ‚ (df1) cu INDEX (df2)
df_complet = df1.merge(df2, left_on='Judet', right_index=True)
```

### **5ï¸âƒ£ AGREGARE (localitÄƒÈ›i â†’ judeÈ›e)**
```python
df_judet = df[industrii + ['Populatie', 'Judet']].groupby('Judet').sum()
```

### **6ï¸âƒ£ PONDERE (raport Ã®ntre douÄƒ coloane)**
```python
pondere = df.apply(
    lambda x: x[industrii].sum() / x['Populatie'],
    axis=1
)
```

### **7ï¸âƒ£ GÄ‚SEÈ˜TE MAXIMUL (activitatea dominantÄƒ)**
```python
dominant = df[industrii].apply(
    lambda x: x.index[x.argmax()],  # x.argmax() = poziÈ›ia max
    axis=1                           # x.index[...] = numele coloanei
)
```

### **8ï¸âƒ£ MEDIE PONDERATÄ‚**
```python
def medie_ponderata(t):
    x = t.values
    m = np.average(x[:, :-1], axis=0, weights=x[:, -1])
    return pd.Series(m, t.columns[:-1])

# Folosire:
medii = df.groupby('Regiune').apply(medie_ponderata, include_groups=False)
```

### **9ï¸âƒ£ INDICE LOCALIZARE**
```python
total_national = df_judet.sum(axis=0)

indici = df_judet[industrii].apply(
    lambda x: (x / total_national[industrii]) / 
              (df_judet.loc[x.name, 'Populatie'] / total_national['Populatie']),
    axis=1
)
```

### **ğŸ”Ÿ SORTARE + EXPORT**
```python
result.sort_values(ascending=False, inplace=True)  # DescrescÄƒtor
result.to_csv("data_out/Cerinta_X.csv")
```

---

## ğŸš¨ CELE MAI IMPORTANTE REGULI

1. **DupÄƒ ORICE Ã®mpÄƒrÈ›ire â†’ `fillna(0)`**
2. **axis=1** = pe rÃ¢nduri (â†’), **axis=0** = pe coloane (â†“)
3. **Merge**: `left_index=True` SAU `left_on='Col'` (nu amesteca!)
4. **GroupBy** schimbÄƒ nivelul (localitÄƒÈ›i â†’ judeÈ›e)
5. **argmax()** = poziÈ›ia, **index[argmax()]** = numele

---

## ğŸ“ TEMPLATE MINIMAL PENTRU ORICE CERINÈšÄ‚

```python
import pandas as pd
import numpy as np

# 1. ÃNCÄ‚RCARE
df = pd.read_csv("data_in/IndustriaAlimentara.csv", index_col=0)
populatie = pd.read_csv("data_in/PopulatieLocalitati.csv", index_col=0)
industrii = ['Carne', 'Peste', 'LegumeFructe', 'Uleiuri', 
             'Lactate', 'Morarit', 'Panificatie']

# 2. MERGE (dacÄƒ e nevoie)
df = df.merge(populatie, left_index=True, right_index=True)

# 3. FILTRARE (dacÄƒ e nevoie)
df = df[df[industrii].sum(axis=1) > 0]

# 4. AGREGARE (dacÄƒ e nevoie)
df_judet = df[industrii + ['Populatie', 'Judet']].groupby('Judet').sum()

# 5. CALCUL
result = df_judet.apply(lambda x: FORMULA_TA, axis=1)

# 6. CURÄ‚ÈšARE
result.fillna(0, inplace=True)

# 7. SORTARE + EXPORT
result.sort_values(ascending=False, inplace=True)
result.to_csv("data_out/Cerinta_X.csv")
```

---

## ğŸ¯ CELE 6 CERINÈšE - REZUMAT ULTRA-SCURT

```python
# CERINÈšA 1: Filtrare
cerinta1 = df[df[industrii].sum(axis=1) > 0]

# CERINÈšA 2: Normalizare
cerinta2 = df[industrii].apply(lambda x: x/x.sum(), axis=1)
cerinta2.fillna(0, inplace=True)

# CERINÈšA 3: Pondere pe judeÈ›e (sortatÄƒ)
df_judet = df.groupby('Judet').sum()
cerinta3 = df_judet.apply(lambda x: x[industrii].sum()/x['Populatie'], axis=1)
cerinta3.sort_values(ascending=False, inplace=True)

# CERINÈšA 4: Activitate dominantÄƒ
cerinta4 = df_judet[industrii].apply(lambda x: x.index[x.argmax()], axis=1)

# CERINÈšA 5: Medie ponderatÄƒ pe regiuni
cerinta5 = df.groupby('Regiune').apply(medie_ponderata, include_groups=False)

# CERINÈšA 6: Indici localizare
total = df_judet.sum(axis=0)
cerinta6 = df_judet[industrii].apply(
    lambda x: (x/total[industrii]) / (df_judet.loc[x.name,'Populatie']/total['Populatie']),
    axis=1
)
```

---

**Asta e tot ce ai nevoie! SalveazÄƒ asta È™i ai 90% din examen rezolvat! ğŸš€**

**Mult succes! ğŸ’ªğŸ“**
